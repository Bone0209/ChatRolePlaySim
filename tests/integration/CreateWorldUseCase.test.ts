
import { test, describe, before, after } from 'node:test';
import assert from 'node:assert';
import path from 'path';

import { PrismaWorldRepository, PrismaEntityRepository, PrismaLocationRepository } from '../../main/infrastructure/repositories';
import { CreateWorldUseCase } from '../../main/application/usecases/world/CreateWorldUseCase';
import { LlmGateway } from '../../main/infrastructure/gateways/LlmGateway';
import { CreateWorldRequestDto } from '../../main/application/dtos';
import prisma from '../../main/infrastructure/database/prisma';

// Mock LlmGateway
class MockLlmGateway extends LlmGateway {
    async generateJson(systemPrompt: string, userPrompt: string, options: any): Promise<any> {
        return {
            location: {
                name: 'Generated Location',
                description: 'A location generated by AI'
            },
            npc: {
                environment: {
                    name: { val: 'Generated NPC', category: 'basic', vis: 'vis_public' },
                    appearance: { val: 'Looks cool', category: 'persona', vis: 'vis_public' },
                    gender: { val: 'Female', category: 'persona', vis: 'vis_public' }
                }
            }
        };
    }
}

describe('CreateWorldUseCase Integration', () => {
    let worldRepo: PrismaWorldRepository;
    let entityRepo: PrismaEntityRepository;
    let locationRepo: PrismaLocationRepository;
    let useCase: CreateWorldUseCase;
    let mockLlmGateway: MockLlmGateway;

    before(async () => {
        // Repos
        worldRepo = new PrismaWorldRepository();
        entityRepo = new PrismaEntityRepository();
        locationRepo = new PrismaLocationRepository();
        mockLlmGateway = new MockLlmGateway();

        // Seed Attribute Definitions to satisfy FK constraints
        const definitions = [
            { key: 'name', type: 'string', cat: 'basic' },
            { key: 'appearance', type: 'string', cat: 'persona' },
            { key: 'gender', type: 'string', cat: 'persona' },
            { key: 'location', type: 'string', cat: 'state' },
            { key: 'locationId', type: 'string', cat: 'state' },
            { key: 'currentHp', type: 'integer', cat: 'state' },
            { key: 'maxHp', type: 'integer', cat: 'parameter' },
            // Potential defaults or hidden keys
            { key: 'firstPerson', type: 'string', cat: 'persona' },
            { key: 'sentenceEnding', type: 'string', cat: 'persona' },
            { key: 'personality', type: 'string', cat: 'persona' },
            { key: 'role', type: 'string', cat: 'persona' },
            { key: 'tone', type: 'string', cat: 'persona' },
            { key: 'background', type: 'string', cat: 'persona' },
            { key: 'race', type: 'string', cat: 'persona' },
            { key: 'ageGroup', type: 'string', cat: 'persona' },
            { key: 'description', type: 'string', cat: 'basic' }
        ];

        for (const def of definitions) {
            await (prisma as any).mAttributeDefinition.upsert({
                where: { keyName: def.key },
                update: {},
                create: {
                    keyName: def.key,
                    valueType: def.type,
                    category: def.cat,
                    description: `Test ${def.key}`
                }
            });
        }

        useCase = new CreateWorldUseCase(
            worldRepo,
            locationRepo,
            entityRepo,
            mockLlmGateway,
            path.join(process.cwd(), 'main', 'prompts')
        );
    });

    after(async () => {
        // No explicit disconnect needed for singleton
    });

    test('should create a world with generated location and entities', async () => {
        const id = 'test-world-' + Date.now();
        const request: CreateWorldRequestDto = {
            id: id,
            name: 'Integration Test World',
            prompt: 'Test Prompt',
            entities: [] // Empty to trigger auto-generation
        };

        const result = await useCase.execute(request);

        assert.ok(result.id, 'World ID should be generated');
        assert.strictEqual(result.name, 'Integration Test World');

        // Verify World in DB
        const world = await (prisma as any).mWorld.findUnique({
            where: { id: result.id }
        });
        assert.ok(world, 'World record should exist');

        // Verify Location
        const locations = await (prisma as any).mLocation.findMany({
            where: { worldId: result.id }
        });
        assert.strictEqual(locations.length, 1, 'Should have 1 location generated');
        const loc = locations[0];
        // MLocation does not have 'name'. Name is in TLocation.

        // Verify T_Location (Name and Description)
        const tLoc = await (prisma as any).tLocation.findFirst({
            where: { locationId: loc.id }
        });
        assert.ok(tLoc, 'T_Location should exist');
        assert.strictEqual(tLoc.name, 'Generated Location');
        assert.strictEqual(tLoc.description, 'A location generated by AI');

        // Verify Entities
        const entities = await (prisma as any).mEntity.findMany({
            where: { worldId: result.id }
        });
        // Should have NPC and Player (CreateWorldUseCase generates both)
        assert.strictEqual(entities.length, 2, 'Should have 2 entities (NPC + Player)');

        const npc = entities.find((e: any) => e.type === 'ENTITY_NPC');
        assert.ok(npc, 'NPC should exist');

        // Verify NPC Location Attribute using Repository
        const domainNpc = await entityRepo.findById(npc.id);
        assert.ok(domainNpc, 'Entity should be retrievable by Repo');

        // Use getter for location ID
        const locationIdActual = domainNpc!.getLocationId();
        assert.strictEqual(locationIdActual, loc.id, 'NPC should be at the generated location (id)');

        // Use attribute getter for location Name
        const locName = domainNpc!.getParameterValue('location');
        assert.strictEqual(locName, 'Generated Location', 'NPC location name attribute should match');
    });
});
