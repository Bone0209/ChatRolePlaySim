# チャットフォーマット検討資料

本ドキュメントでは、チャット機能における「レスポンス（AI出力）」と「リクエスト（AIへの入力）」のフォーマットについて、現状の課題と代替案を整理します。
特に、**感情表現**などのメタデータを明確に分離し、かつAIが扱いやすい形式を検討します。

## 1. チャットのレスポンス（AI出力）について

現状はMarkdownの斜体(`*example*`)を使用していますが、パースの曖昧さや処理速度の懸念があります。
以下に、より堅牢なフォーマット案を提示します。

### パターンA: JSONフォーマット (推奨)
構造化データとして最も一般的であり、現在のLLM（Large Language Models）が最も得意とする形式です。

**特徴:**
- **AI適性:** 極めて高い（多くのモデルにJSONモードがある）。
- **パース:** 容易かつ確実（標準ライブラリで処理可能）。
- **拡張性:** 新しいフィールド（信頼度、思考プロセスなど）を容易に追加可能。

**例:**
```json
{
  "emotion": "joy",
  "thought": "ユーザーが喜んでいるので、少しはしゃいだ感じで返そう",
  "content": "わあ、本当ですか！それは素晴らしいですね！"
}
```

### パターンB: XML/HTMLライク記法
タグベースで構造を明示する方法です。テキストとの親和性が高く、可読性を維持しやすいです。

**特徴:**
- **AI適性:** 高い（プロンプトで指示しやすい）。
- **パース:** 正規表現やXMLパーサーで処理可能。
- **可読性:** JSONより「文章」として自然に見える。

**例:**
```xml
<emotion type="joy">わあ、本当ですか！</emotion>
<action>飛び跳ねる</action>
それは素晴らしいですね！
```

### パターンD: ハイブリッド (JSON + XML文字列)
JSONの外殻でメタデータを管理し、本文(`chat_body`)にXML/HTMLライクな文字列を含める方法です。

**特徴:**
- **構造と自由度の両立:** APIとしての扱いやすさ(JSON)と、テキスト表現の自由度(XML)を両立できる。
- **実装:** フロントエンドで`dangerouslySetInnerHTML`的なレンダリングをする場合に直結しやすい。
- **課題:** JSON文字列内のXMLはエスケープ(`\"`)が多くなるため、LLMが構文エラーを起こすリスクが少し上がる。

    **エスケープの具体例:**
    XMLの属性でダブルクォートを使用する場合、JSON文字列内ではエスケープが必要です。
    ```json
    // 悪い例 (構文エラー)
    { "chat_body": "<emotion type="joy">..." }

    // 正しい例 (エスケープが必要)
    { "chat_body": "<emotion type=\"joy\">..." }
    ```
    さらに、改行を含む場合も `\n` に変換する必要があります。
    ```json
    { "chat_body": "<action>溜息をつく</action>\n<speak>はぁ...</speak>" }
    ```

**例:**
```json
{
  "status": "success",
  "emotion_summary": "joy",
  "chat_body": "<emotion type=\"joy\">わあ、本当ですか！</emotion><action>飛び跳ねる</action>それは素晴らしいですね！"
}
```

### パターンC: カスタムブロック記法 (Frontmatter風)
メッセージの冒頭にメタデータを配置し、セパレータで本文と分ける方法です。

**特徴:**
- **AI適性:** 中〜高。
- **可読性:** メタデータが上部にまとまるため見やすい。

**例:**
```yaml
---
emotion: joy
action: jump
---
わあ、本当ですか！それは素晴らしいですね！
```

### 厳格なタグ制限 (Strict Tag Constraint)
上記のXML/ハイブリッド形式を採用する場合、使用するタグを厳密に定義することで、解析の確実性と表現のブレを防ぎます。
以下の3〜4つに絞るのが効果的です。

- `<speak>`: キャラクターのセリフ（音声合成やテキスト表示用）。
- `<emotion>`: 感情パラメータ。立ち絵の差分切り替えに使用。
- `<action>`: キャラクターの動作。
- `<thought>`: 心の声（※必要であれば）。

**例:**
```xml
<emotion type="surprise">えっ！？</emotion>
<action>あとずさりする</action>
<speak>まさか、あなたがそこまで知っているなんて...</speak>
<thought>（この秘密を知っているのは私だけのはずなのに...）</thought>
```

**メリット:**
- **パース容易性:** 特定のタグのみを探せばよいため、正規表現でも処理が可能になる。
- **指示の明確化:** LLMに対しても「このタグ以外は使うな」と指示することで、ハルシネーションを抑制できる。
- **ゲーム的マッピング:** `emotion`=立ち絵, `speak`=メッセージウィンドウ とUI要素へのマッピングが直感的。

### パターンE: ドット記法タグ (Dot Notation Tags)
「属性のクォート地獄」を回避するための、ユーザー提案による改良パターンです。
タグ名自体にタイプを含めることで、属性値のダブルクォートを排除します。

**形式:** `<Category.Type>Content</Category.Type>`

**例:**
```xml
<emotion.surprise>えっ！？</emotion.surprise>
<action.step_back>あとずさりする</action.step_back>
<speak>まさか、あなたがそこまで知っているなんて...</speak>
```

**JSON内での見た目:**
```json
{
  "chat_body": "<emotion.surprise>えっ！？</emotion.surprise><speak>...</speak>"
}
```

**メリット:**
- **エスケープ不要:** ダブルクォートを使わないため、JSON文字列として非常に安全。
- **トークン効率:** ` type="..."` という冗長な記述を省略できる。

**デメリット:**
- **終了タグの冗長性:** `</emotion.surprise>` と書くか、パーサー側で `</emotion.*>` を許容するかの設計が必要。
  - *解決策:* 終了タグは単純な `</emotion>` や `</>` で済むようにパーサーを自作/調整すると楽。

---

## 3. 最終案: 配列型ショートタグフォーマット (Array-based Short Tag Format)
これまでの検討とトークン削減・パース安定性を考慮した最終推奨フォーマットです。
属性を廃止し、タグ名を短縮形(`emo`, `act`)に統一。配列構造で複数のメッセージタイプ（会話、ログ、イベント）を一括で扱います。

**JSON構造:**
```json
{
  "chats": [
    {
      "type": "C",
      "order": 1,
      "body": "<emo>joy</emo>\n<act>jump</act>\n<msg>わあ、本当ですか！</msg>"
    },
    {
      "type": "I",
      "order": 2,
      "body": "好感度が上がった音がした。"
    }
  ]
}
```

**キー定義:**
- `type`: メッセージの種類を1文字で指定。
  - `"C"`: Chat (通常の会話)
  - `"I"`: Information (システムログ、情報)
  - `"E"`: Event (イベント発生通知)
- `order`: 表示順序 (数値)。
- `body`: コンテンツ本文。タグとテキストを含む。

**タグ定義 (Chat用):**
- `<emo>`: 感情 (Emotion)。値は定義済みの感情キー(joy, sadなど)。属性なし。
- `<act>`: 動作 (Action)。
- `<msg>`: 発言内容 (Message)。`<speak>`の短縮。

**ルール:**
1. **属性禁止:** `<tag attr="...">` は使用しない。値はすべてタグの中身に書く。
2. **改行区切り:** パースしやすくするため、タグ間には必ず改行 `\n` を入れることをルールとする。
3. **短縮タグ:** トークン節約のため、タグ名は3文字程度に短縮する。

**メリット:**
- **極めて軽量:** 短縮タグと属性廃止によりトークン消費が最小限。
- **柔軟性:** 配列構造により、一回のレスポンスで「会話」と「システムログ」を同時に返せる。
- **安全性:** 属性を使わないためJSONエスケープの問題が起きにくい。

---

## 4. 最終案: リクエスト（入力）のフォーマット
**結論: レスポンスと同じXML/タグ形式を採用することを推奨します。**

ユーザーから「今の構造を参考にする」「レスポンスと同じにする」という提案がありましたが、これは**AIにとっても非常にメリットが大きい**です。
出力してほしい形式そのものを入力として見せることで、AIは「この形式で返せばいいのだ」と直感的に理解できます（Few-shot効果）。

### XML/タグ形式は不都合か？
**いいえ、むしろ好都合です。**
- **AIの特性:** 最近のLLM（Claude, GPT-4oなど）はXMLタグの理解能力が非常に高く、構造化データのインプットとして自然に処理できます。
- **対称性:** 「入力されたタグ(`emo`, `act`)を見て、出力のタグを生成する」というタスクは、形式変換させるよりも低負荷で精度が高くなります。

### 推奨構造（プロンプトに含める入力）

ユーザーの入力をシステムが整形し、以下の形式でAIに渡します。

```xml
<user_chats>
  <chat type="C">
    <emo>angry</emo>
    <act>glare</act>
    <msg>なんでそんなことをしたの？</msg>
  </chat>
</user_chats>
```

**マッピング:**
- ユーザーの手入力: `[angry] なんで？`
  ↓ システム内部で変換
- AIへの入力: `<emo>angry</emo><msg>なんで？</msg>`

これにより、リクエストとレスポンスの構造が「完全に対称」となり、一貫性が保たれます。

ユーザーの状態や感情、またはシステムからの指示（ウィグシグ的介入）を明確に伝えるためのフォーマットです。

### パターンA: 埋め込みタグ記法 (一般的・簡易)
文章中に感情や状況を表すタグを挿入します。チャットボット界隈で古くから使われる「ウィグシグ（WigWag）」的なアプローチです。

**特徴:**
- **直感的:** ユーザーが手打ちもしやすい。
- **コンテキスト:** 文章の特定の位置に感情を紐付けやすい。

**例:**
```text
[emotion:angry] なんでそんなことをしたの？ [action:sigh] 言い訳は聞きたくないわ。
```
または省略形:
```text
(怒り) なんでそんなことをしたの？ (ため息)
```

### パターンB: 構造化プロンプト (AI最適化)
システムプロンプトやメッセージ履歴とは別に、明確な「状態指示」ブロックとして渡す方法です。

**特徴:**
- **明確さ:** 発言内容と、その裏にある感情・意図を完全に分離できる。
- **制御:** AIに対して「ロールプレイ」の指示として強く機能する。

**例 (APIリクエストイメージ):**
```json
{
  "role": "user",
  "content": "なんでそんなことをしたの？",
  "context": {
    "user_emotion": "angry",
    "user_action": "kicking the ground",
    "environment": "raining"
  }
}
```

実際のプロンプト構成時:
```markdown
[User Context]
Emotion: Angry
Action: Kicking the ground

[User Message]
なんでそんなことをしたの？
```

## 推奨構成

### レスポンス（出力）
**JSONフォーマット**を推奨します。
フロントエンドでの表示処理（立ち絵の変更、演出）とテキスト表示をプログラム的に確実に分離できるため、バグが少なく拡張性が高いです。

### リクエスト（入力）
**構造化プロンプト（パターンB）**と**埋め込みタグ（パターンA）**のハイブリッドを推奨します。
- ユーザーの基本状態はコンテキストブロックとして渡す。
- 詳細な演技指導（ここだけ笑って、など）は埋め込みタグで指示する。

```markdown
User: [joy] やったー！ [sad] でも疲れちゃった...
```
↓
AIへの指示:
「ユーザーは前半で喜び、後半で悲しんでいます。その落差に反応してください。」
```
